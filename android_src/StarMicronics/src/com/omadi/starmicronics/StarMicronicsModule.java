/**
 * This file was auto-generated by the Titanium Module SDK helper for Android
 * Appcelerator Titanium Mobile
 * Copyright (c) 2009-2010 by Appcelerator, Inc. All Rights Reserved.
 * Licensed under the terms of the Apache Public License
 * Please see the LICENSE included with this distribution for details.
 *
 */
package com.omadi.starmicronics;

import java.util.HashMap;

import org.appcelerator.kroll.KrollDict;
import org.appcelerator.kroll.KrollFunction;
import org.appcelerator.kroll.KrollModule;
import org.appcelerator.kroll.KrollObject;
import org.appcelerator.kroll.KrollRuntime;
import org.appcelerator.kroll.annotations.Kroll;

import org.appcelerator.titanium.TiApplication;
import org.appcelerator.titanium.TiBaseActivity;
import org.appcelerator.titanium.TiContext;
import org.appcelerator.titanium.util.TiActivityResultHandler;
import org.appcelerator.titanium.util.TiActivitySupport;
import org.appcelerator.kroll.common.Log;

import android.app.Activity;
import android.content.ContentValues;
import android.content.Intent;
import android.os.Message;
import android.provider.MediaStore.Images;
import java.util.List;
import java.util.ArrayList;
import java.util.Arrays;

import com.starmicronics.stario.StarIOPort;
import com.starmicronics.stario.PortInfo;
import com.starmicronics.stario.StarIOPortException; 
import com.starmicronics.stario.StarPrinterStatus;

@Kroll.module(name="Starmicronics", id="com.omadi.starmicronics")
public class StarMicronicsModule extends KrollModule{
	
	// Standard Debugging variables
	private static final String LCAT = "StarMicronicsModule";
	protected static final int MSG_INVOKE_CALLBACK = KrollModule.MSG_LAST_ID + 100;
	
	private StarIOPort port = null;
	
	@Kroll.constant public static final int UNKNOWN_ERROR = 0;
	
	static KrollFunction finishedCallback = null;
	// You can define constants with @Kroll.constant, for example:
	// @Kroll.constant public static final String EXTERNAL_NAME = value;
	
	public StarMicronicsModule()
	{
		super();
	}

	@Kroll.onAppCreate
	public static void onAppCreate(TiApplication app)
	{
		Log.d(LCAT, "inside star micronics onAppCreate");
		// put module init code that needs to run when the application is created
	}

	private static StarMicronicsModule _instance;

	public static StarMicronicsModule getInstance(){
		return _instance;
  	}

  	public StarMicronicsModule(TiContext tiContext)
  	{
	  	super(tiContext);
   		_instance = this;
    }
  	
  	@Kroll.method
  	public void getBluetoothDeviceList(HashMap options){
  		KrollFunction errorCallback = null;
		KrollFunction successCallback = null;

		if (options.containsKey("success")) {
			successCallback = (KrollFunction) options.get("success");
		}
		if (options.containsKey("error")) {
			errorCallback = (KrollFunction) options.get("error");
		}
		
		Activity activity = TiApplication.getInstance().getCurrentActivity();
		
		KrollDict d = new KrollDict();
		List<String> portNames = new ArrayList<String>();
		
		Log.i("PRINT", "PRINT Device List Coming");
		
		try {
			List<PortInfo> portList = StarIOPort.searchPrinter("BT:"); 
			
			for (PortInfo port : portList) {
				portNames.add(port.getPortName());
				
				Log.i("PRINT", "PRINT Port Name: " + port.getPortName());
				Log.i("PRINT", "PRINT MAC Address: " + port.getMacAddress()); 
			}
			
			if(portList.size() > 0){
				d.put("portNames", portNames.toArray(new String[0]));
				invokeCallback((TiBaseActivity) activity, successCallback, getKrollObject(), d);
			}
			else{
				d.put("error", "No blue tooth devices available.");
				invokeCallback((TiBaseActivity) activity, errorCallback, getKrollObject(), d);
			}
		}
		catch (StarIOPortException e) {
			d.put("error", e.getMessage());
			invokeCallback((TiBaseActivity) activity, errorCallback, getKrollObject(), d);
		}
  	}
  	
  	@Kroll.method
  	public void openPort(HashMap options){
  		
  		KrollFunction errorCallback = null;
		KrollFunction successCallback = null;

		if (options.containsKey("success")) {
			successCallback = (KrollFunction) options.get("success");
		}
		if (options.containsKey("error")) {
			errorCallback = (KrollFunction) options.get("error");
		}
		
		String portName = (String)options.get("portName");
		
		Activity activity = TiApplication.getInstance().getCurrentActivity();
		
		KrollDict d = new KrollDict();
		
		try {
			this.port = StarIOPort.getPort(portName, "mini", 10000);
			invokeCallback((TiBaseActivity) activity, successCallback, getKrollObject(), d);
		}
		catch (StarIOPortException e) {
			d.put("error", e.getMessage());
			invokeCallback((TiBaseActivity) activity, errorCallback, getKrollObject(), d);
		}
  	}
  	
  	@Kroll.method
  	public void releasePort(HashMap options){
  		
  		KrollFunction errorCallback = null;
		KrollFunction successCallback = null;

		if (options.containsKey("success")) {
			successCallback = (KrollFunction) options.get("success");
		}
		if (options.containsKey("error")) {
			errorCallback = (KrollFunction) options.get("error");
		}
		
		Activity activity = TiApplication.getInstance().getCurrentActivity();
		
		KrollDict d = new KrollDict();
		
		try {
			StarIOPort.releasePort(this.port);
			invokeCallback((TiBaseActivity) activity, successCallback, getKrollObject(), d);
		}
		catch (StarIOPortException e) {
			d.put("error", e.getMessage());
			invokeCallback((TiBaseActivity) activity, errorCallback, getKrollObject(), d);
		}
  	}
	
	@Kroll.method
	public void print(HashMap options)
	{
		KrollFunction errorCallback = null;
		KrollFunction successCallback = null;
		String portName = null;
		//byte[] commands;

		if (options.containsKey("success")) {
			successCallback = (KrollFunction) options.get("success");
		}
		if (options.containsKey("error")) {
			errorCallback = (KrollFunction) options.get("error");
		}
		
		Log.i("PRINT", "PRINT in print");
		
		portName = (String)options.get("portName");
		
		ti.modules.titanium.BufferProxy buffer = (ti.modules.titanium.BufferProxy)options.get("commands");
		
		Log.i("PRINT", "PRINT 1");
		
		byte[] commands;
		KrollDict d = new KrollDict();
		Activity activity = TiApplication.getInstance().getCurrentActivity();
		
		StarIOPort port = null;
		
		Log.i("PRINT", "PRINT in print2");
		
		try{
			
	        commands = buffer.getBuffer();
	        Log.i("PRINT", "PRINT ===KABOOM===");
	        for(int i = 0; i < commands.length; i ++){
				Log.i("PRINT", "PRINT " + commands[i]);
			}
	        
	        
	        Log.i("PRINT", "PRINT " + commands.toString());
			/*
				using StarIOPort3.1.jar (support USB Port)
				Android OS Version: upper 2.2
			*/
			port = StarIOPort.getPort(portName, "mini", 20000);
			/* 
				using StarIOPort.jar
				Android OS Version: under 2.1
				port = StarIOPort.getPort(portName, portSettings, 10000);
			*/
			try
			{
				Thread.sleep(500);
			}
			catch (InterruptedException e) { }

			/*
		    Portable Printer Firmware Version 2.4 later, SM-S220i(Firmware Version 2.0 later) 

            Using Begin / End Checked Block method for preventing "data detective".
            
            When sending large amounts of raster data,
            use Begin / End Checked Block method and adjust the value in the timeout in the "StarIOPort.getPort"
            in order to prevent "timeout" of the "endCheckedBlock method" while a printing.
            
            *If receipt print is success but timeout error occurs(Show message which is "There was no response of the printer within the timeout period."),
             need to change value of timeout more longer in "StarIOPort.getPort" method. (e.g.) 10000 -> 30000
            *When use "Begin / End Checked Block Sample Code", do comment out "query commands Sample code".
		    */

		    /* Start of Begin / End Checked Block Sample code */
			StarPrinterStatus status = port.beginCheckedBlock();

			if (true == status.offline){
				d.put("error", "Printer is offline.");
				invokeCallback((TiBaseActivity) activity, errorCallback, getKrollObject(), d);
			}
			
			
			ArrayList<Byte> list = new ArrayList<Byte>();
            Byte[] tempList;
			byte[] outputByteBuffer = null;
			
			list.addAll(Arrays.asList(new Byte[]{0x1d, 0x57, 0x40, 0x32}));           //Page Area Setting     <GS> <W> nL nH  (nL = 64, nH = 2)
			
			list.addAll(Arrays.asList(new Byte[]{0x1b, 0x61, 0x01}));                 //Center Justification  <ESC> a n       (0 Left, 1 Center, 2 Right)
			
//            outputByteBuffer = ("[Print Stored Logo Below]\n\n").getBytes();
//            port.writePort(outputByteBuffer, 0, outputByteBuffer.length);
//			
//            list.addAll(Arrays.asList(new Byte[]{0x1b, 0x66, 0x00}));                 //Stored Logo Printing  <ESC> f n       (n = Store Logo # = 0 or 1 or 2 etc.)
			
			outputByteBuffer = ("\nStar Clothing Boutique\n" +
					            "123 Star Road\n" +
					            "City, State 12345\n\n").getBytes();
			tempList = new Byte[outputByteBuffer.length];
			CopyArray(outputByteBuffer, tempList);
			list.addAll(Arrays.asList(tempList));
			
			byte[] commands2 = convertFromListByteArrayTobyteArray(list);
			
			Log.i("PRINT", "PRINT ***BOOM***");
			for(int i = 0; i < commands2.length; i ++){
				Log.i("PRINT", "PRINT " + commands2[i]);
			}

			port.writePort(commands, 0, commands.length);

			status = port.endCheckedBlock();

			if (true == status.coverOpen){
				d.put("error", "Printer cover is open.");
				invokeCallback((TiBaseActivity) activity, errorCallback, getKrollObject(), d);
			}
			else if (true == status.receiptPaperEmpty){
				d.put("error", "Receipt paper is empty.");
				invokeCallback((TiBaseActivity) activity, errorCallback, getKrollObject(), d);
			}
			else if (true == status.offline){
				d.put("error", "Printer is offline.");
				invokeCallback((TiBaseActivity) activity, errorCallback, getKrollObject(), d);
			}
			else{
				invokeCallback((TiBaseActivity) activity, successCallback, getKrollObject(), d);
			}
			/* End of Begin / End Checked Block Sample code*/
			/*
			    Portable Printer Firmware Version 2.3 earlier

                Using query commands for preventing "data detective".
                
				When sending large amounts of raster data,
				send query commands after writePort data for confirming the end of printing 
				and adjust the value in the timeout in the "checkPrinterSendToComplete" method
				in order to prevent "timeout" of the "sending query commands" while a printing.
                
				*If receipt print is success but timeout error occurs(Show message which is "There was no response of the printer within the timeout period."),
				 need to change value of timeout more longer in "checkPrinterSendToComplete" method. (e.g.) 10000 -> 30000
				*When use "query commands Sample code", do comment out "Begin / End Checked Block Sample Code".
			 */

			/* Start of query commands Sample code */
//            byte[] commandToSendToPrinter = convertFromListByteArrayTobyteArray(byteList);
//			port.writePort(commandToSendToPrinter, 0, commandToSendToPrinter.length);
//			
//			checkPrinterSendToComplete(port);
			/* End of query commands Sample code */
		}
		catch (StarIOPortException e){
			d.put("error", e.getMessage());
			invokeCallback((TiBaseActivity) activity, errorCallback, getKrollObject(), d);
		}
		finally
		{
			if (port != null)
			{
				try
				{
					StarIOPort.releasePort(port);
				}
				catch (StarIOPortException e) { }
			}
		}
	}
	
	private static void CopyArray(byte[] srcArray, Byte[] cpyArray) {
    	for (int index = 0; index < cpyArray.length; index++) {
    		cpyArray[index] = srcArray[index];
    	}
    }
	
	private static byte[] convertFromListByteArrayTobyteArray(List<Byte> ByteArray)
	{
		byte[] byteArray = new byte[ByteArray.size()];
		for(int index = 0; index < byteArray.length; index++)
		{
			if (null == ByteArray.get(index)) {
				byteArray[index] = 0;
			}
			else
			{
			    byteArray[index] = ByteArray.get(index);
			}
		}
		
		return byteArray;
	}
	
	protected class StarMicronicsResultHandler implements TiActivityResultHandler, Runnable{
		
		protected int code;
		protected KrollFunction successCallback, cancelCallback, errorCallback;
		protected TiActivitySupport activitySupport;
		protected Intent cameraIntent;

		@Override
		public void run()
		{
			code = activitySupport.getUniqueResultCode();
			activitySupport.launchActivityForResult(cameraIntent, code, this);
		}

		@Override
		public void onResult(Activity activity, int requestCode, int resultCode, Intent data)
		{
			if (resultCode == Activity.RESULT_CANCELED) {
				
				if (cancelCallback != null) {
					cancelCallback.callAsync(getKrollObject(), new Object[] {});
				}

			} 
			else {
				if (data == null) {
					ContentValues values = new ContentValues(7);
				
					values.put(Images.Media.MIME_TYPE, "image/jpeg");
			

					try {
						if (successCallback != null) {
							KrollDict d = new KrollDict();
							invokeCallback((TiBaseActivity) activity, successCallback, getKrollObject(), d);
						}

					} catch (OutOfMemoryError e) {
						String msg = "Not enough memory to do this: " + e.getMessage();
						Log.e(LCAT, msg);
						if (errorCallback != null) {
							invokeCallback((TiBaseActivity) activity, errorCallback, getKrollObject(), createErrorResponse(UNKNOWN_ERROR, msg));
						}
					}

				} 
				else {
					
				}
			}
		}

		@Override
		public void onError(Activity activity, int requestCode, Exception e) {
			
			String msg = "star micronics problem: " + e.getMessage();
			Log.e(LCAT, msg, e);
			if (errorCallback != null) {
				errorCallback.callAsync(getKrollObject(), createErrorResponse(UNKNOWN_ERROR, msg));
			}
		}
	}
	
	private void invokeCallback(TiBaseActivity callbackActivity, KrollFunction callback, KrollObject krollObject, KrollDict callbackArgs)
	{
		if (KrollRuntime.getInstance().isRuntimeThread()) {
			doInvokeCallback(callbackActivity, callback, krollObject, callbackArgs);

		} else {
			CallbackWrapper callbackWrapper = new CallbackWrapper(callbackActivity, callback, krollObject, callbackArgs);
			Message message = getRuntimeHandler().obtainMessage(MSG_INVOKE_CALLBACK, callbackWrapper);
			message.sendToTarget();
		}
	}
	
	private void doInvokeCallback(TiBaseActivity callbackActivity, KrollFunction callback, KrollObject krollObject, KrollDict callbackArgs)
	{
		if (callbackActivity.isResumed) {
			callback.callAsync(krollObject, callbackArgs);

		} else {
			CallbackWrapper callbackWrapper = new CallbackWrapper(callbackActivity, callback, krollObject, callbackArgs);
			Message message = getRuntimeHandler().obtainMessage(MSG_INVOKE_CALLBACK, callbackWrapper);
			message.sendToTarget();
		}
	}
	
	/**
	 * Object that is used to wrap required fields for async processing when invoking 
	 * success, error , etc callbacks for camera
	 */
	private class CallbackWrapper
	{
		public TiBaseActivity callbackActivity;
		public KrollFunction callback;
		public KrollObject krollObject;
		public KrollDict callbackArgs;

		CallbackWrapper(TiBaseActivity callbackActivity, KrollFunction callback, KrollObject krollObject, KrollDict callbackArgs)
		{
			this.callbackActivity = callbackActivity;
			this.callback = callback;
			this.krollObject = krollObject;
			this.callbackArgs = callbackArgs;
		}
	}
}

