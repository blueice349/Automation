/**
 * This file was auto-generated by the Titanium Module SDK helper for Android
 * Appcelerator Titanium Mobile
 * Copyright (c) 2009-2010 by Appcelerator, Inc. All Rights Reserved.
 * Licensed under the terms of the Apache Public License
 * Please see the LICENSE included with this distribution for details.
 *
 */
package com.omadi.newcamera;

import java.io.BufferedInputStream;
import java.io.BufferedOutputStream;
import java.io.ByteArrayOutputStream;
import java.io.File;
import java.io.FileInputStream;
import java.io.FileNotFoundException;
import java.io.FileOutputStream;
import java.io.IOException;
import java.net.MalformedURLException;
import java.net.URL;
import java.util.Date;
import java.util.HashMap;
import java.util.List;

import org.appcelerator.kroll.KrollDict;
import org.appcelerator.kroll.KrollFunction;
import org.appcelerator.kroll.KrollModule;
import org.appcelerator.kroll.KrollObject;
import org.appcelerator.kroll.KrollRuntime;
import org.appcelerator.kroll.annotations.Kroll;

import org.appcelerator.titanium.TiApplication;
import org.appcelerator.titanium.TiBaseActivity;
import org.appcelerator.titanium.TiBlob;
import org.appcelerator.titanium.TiContext;
import org.appcelerator.titanium.io.TiFileFactory;
import org.appcelerator.titanium.proxy.TiViewProxy;
import org.appcelerator.titanium.util.TiActivityResultHandler;
import org.appcelerator.titanium.util.TiActivitySupport;
import org.appcelerator.titanium.util.TiConvert;
import org.appcelerator.titanium.util.TiFileHelper;
import org.appcelerator.titanium.util.TiIntentWrapper;
import org.appcelerator.kroll.common.Log;
import org.appcelerator.kroll.common.TiConfig;

import android.app.Activity;
import android.content.ContentValues;
import android.content.Intent;
import android.content.pm.PackageManager;
import android.content.pm.ResolveInfo;
import android.database.Cursor;
import android.graphics.Bitmap;
import android.graphics.BitmapFactory;
import android.graphics.Matrix;
import android.hardware.Camera;
import android.net.Uri;
import android.os.Message;
import android.provider.MediaStore;
import android.provider.MediaStore.Images;
import ti.modules.titanium.media.android.AndroidModule.MediaScannerClient;


@Kroll.module(name="Newcamera", id="com.omadi.newcamera")
public class NewcameraModule extends KrollModule
{
	
	
	private static final String PHOTO_DCIM_CAMERA = "/sdcard/dcim/Camera";
	
	@Kroll.constant public static final int NO_CAMERA = 2;
	@Kroll.constant public static final int UNKNOWN_ERROR = 0;
	@Kroll.constant public static final String MEDIA_TYPE_PHOTO = "public.image";
	@Kroll.constant public static final String MEDIA_TYPE_VIDEO = "public.video";
	
	// Standard Debugging variables
	private static final String LCAT = "NewcameraModule";
	private static final boolean DBG = TiConfig.LOGD;
	protected static final int MSG_INVOKE_CALLBACK = KrollModule.MSG_LAST_ID + 100;
	
	static KrollFunction finishedCallback = null;
	// You can define constants with @Kroll.constant, for example:
	// @Kroll.constant public static final String EXTERNAL_NAME = value;
	
	public NewcameraModule()
	{
		super();
	}

	@Kroll.onAppCreate
	public static void onAppCreate(TiApplication app)
	{
		Log.d(LCAT, "inside onAppCreate");
		// put module init code that needs to run when the application is created
	}

	private static NewcameraModule _instance;

	public static NewcameraModule getInstance(){
		return _instance;
  	}

  	public NewcameraModule(TiContext tiContext)
  	{
	  	super(tiContext);
   		_instance = this;
    }
	
	@Kroll.method
	public void takePicture()
	{
		// make sure the preview / camera are open before trying to take photo
		if (OmadiCameraActivity.cameraActivity != null) {
			OmadiCameraActivity.cameraActivity.takePicture();
		} else {
			Log.e(LCAT, "camera preview is not open, unable to take photo");
		}
	}
	
	@Kroll.method
	public void resizeImage(String filePath, int degrees){
		
//		BitmapFactory.Options options = new BitmapFactory.Options();
//		options.inJustDecodeBounds = true;
//
//		BitmapFactory.decodeByteArray(data, 0, data.length, options);
//		int imageHeight = options.outHeight;
//		int imageWidth = options.outWidth;
//		int targetHeight = 1024, targetWidth = 768;
//		//String imageType = options.outMimeType;
//		int inSampleSize = 1;
//
//	    if (imageHeight > targetHeight || imageWidth > targetWidth) {
//	        if (imageWidth > imageHeight) {
//	            inSampleSize = Math.round((float)imageHeight / (float)targetHeight);
//	        } else {
//	            inSampleSize = Math.round((float)imageWidth / (float)targetWidth);
//	        }
//	    }
//
//	    if(inSampleSize>=2){
//	    	inSampleSize = (int)Math.pow(2, inSampleSize);
//	    }else if(inSampleSize<2 && inSampleSize>=1){
//	    	inSampleSize = 2;
//	    }
//
//	    Log.d("Pooja", inSampleSize+"");
//	    options.inSampleSize = inSampleSize;
//	    options.inJustDecodeBounds = false;
//	    options.inPurgeable = true;
//	    Matrix mtx = new Matrix();
//
//		if (degrees == 180 || degrees == 0) {
//			mtx.postRotate(degrees);
//		}
//		else if (degrees == 270) {
//			mtx.postRotate(90);
//		}
//		else {
//			mtx.postRotate(270);
//		}

		//Bitmap bitmap = BitmapFactory.decodeByteArray(data, 0, data.length, options);
		//bitmap = Bitmap.createBitmap(bitmap, 0, 0, options.outWidth, options.outHeight, mtx, true);
		
		//FileInputStream imageFile = new FileInputStream(filePath);
		//Log.i("CHRIS", "in resize");
		
		//Log.i("CHRIS", "resize file: " + filePath);
		
		
		//	file:///sdcard/dcim/Camera/Omadi/tia-646219205.jpg

		
		Bitmap bitmap = BitmapFactory.decodeFile(filePath);
		
		if(bitmap != null){
			int height = bitmap.getHeight();
			int width = bitmap.getWidth();
			
			int newWidth = width;
			int newHeight = height;
			
			float scale = 1.0f;
			
			int max = 1024;
			
			if (height > max || width > max) {
		        if (width > height) {
		        	scale = (float)max / (float)width;
		        } 
		        else {
		            scale = (float)max / (float)height;
		        }
		        
		        //Log.i("CHRIS", "resize width: " + width + " " + scale);
		        
		        if(scale > 0){
		        	newWidth = Math.round((float)width * scale);
		        	newHeight = Math.round((float)height * scale);
		        }
		    }
			
			Bitmap resized = null;
			
			//Log.i("CHRIS", "MATRIX DEG: " + degrees);
			
			resized = Bitmap.createScaledBitmap(bitmap, newWidth, newHeight, true);
			
			if(degrees > 0){
				Matrix mtx = new Matrix();

				if (degrees == 180) {
					mtx.postRotate(180);
				}
				else if (degrees == 270) {
					mtx.postRotate(90);
				}
				else {
					mtx.postRotate(270);
				}
				
				resized = Bitmap.createBitmap(resized, 0, 0, newWidth, newHeight, mtx, true);
			}
			
			bitmap.recycle();
			//stream.close();
			bitmap = null;
			
			//Log.i("CHRIS", "resized it");
			
		    //ByteArrayOutputStream stream = new ByteArrayOutputStream();
			//resized.compress(Bitmap.CompressFormat.JPEG, 95, stream);
			
			try {
			       FileOutputStream out = new FileOutputStream(filePath);
			       resized.compress(Bitmap.CompressFormat.JPEG, 90, out);
			       
			} catch (Exception e) {
			       e.printStackTrace();
			       Log.d("CHRIS", e.getMessage());
			}
			
			//Log.i("CHRIS", "resize wrote");
			
			//String ss = Base64.encodeToString(stream.toByteArray(), 0);
	
			
			
			resized.recycle();
			resized = null;
			
			//stream = null;
			//System.gc();
		}
	}
	
	@Kroll.method
	public void showCamera(HashMap options)
	{
		
		KrollFunction cancelCallback = null;
		KrollFunction errorCallback = null;
		KrollFunction successCallback = null;

		if (options.containsKey("success")) {
			successCallback = (KrollFunction) options.get("success");
		}
		if (options.containsKey("cancel")) {
			cancelCallback = (KrollFunction) options.get("cancel");
		}
		if (options.containsKey("error")) {
			errorCallback = (KrollFunction) options.get("error");
		}
		if (options.containsKey("finished")) {
			finishedCallback = (KrollFunction) options.get("finished");
		}
		if (options.containsKey("overlay")) {
			OmadiCameraActivity.overlayProxy = (TiViewProxy) options.get("overlay");
		}

		if (DBG) {
			Log.d(LCAT, "showCamera called");
		}
		
		Camera camera = null;
		
		try {
			camera = Camera.open();
			
			if (camera != null) {
				camera.release();
				camera = null;
			}

		} 
		catch (Throwable t) {
			
			if (camera != null) {
				camera.release();
			}

			if (errorCallback != null) {
				//errorCallback.call(getKrollObject(), new Object[] { createErrorResponse(NO_CAMERA, "Camera not available. " + t.toString()) });
			}

			return;
		}

		Activity activity = TiApplication.getInstance().getCurrentActivity();
		TiActivitySupport activitySupport = (TiActivitySupport) activity;
		TiFileHelper tfh = TiFileHelper.getInstance();

		File imageDir = null;
		File imageFile = null;

		try {
			
			if (activity.getIntent() != null) {
				String name = TiApplication.getInstance().getAppInfo().getName();
				imageDir = new File(PHOTO_DCIM_CAMERA, name);
				if (!imageDir.exists()) {
					imageDir.mkdirs();
					if (!imageDir.exists()) {
						Log.w(LCAT, "Attempt to create '" + imageDir.getAbsolutePath() +  "' failed silently.");
					}
				}

			} else {
				imageDir = tfh.getDataDirectory(false);
			}

			imageFile = tfh.getTempFile(imageDir, ".jpg");

		} catch (IOException e) {
			Log.e(LCAT, "Unable to create temp file", e);
			if (errorCallback != null) {
				errorCallback.callAsync(getKrollObject(), createErrorResponse(UNKNOWN_ERROR, e.getMessage()));
			}

			return;
		}

		String imageUrl = "file://" + imageFile.getAbsolutePath();
		TiIntentWrapper cameraIntent = new TiIntentWrapper(new Intent());

		if(OmadiCameraActivity.overlayProxy == null) {
			cameraIntent.getIntent().setAction(MediaStore.ACTION_IMAGE_CAPTURE);
			cameraIntent.getIntent().addCategory(Intent.CATEGORY_DEFAULT);
		} else {
			cameraIntent.getIntent().setClass(TiApplication.getInstance().getBaseContext(), OmadiCameraActivity.class);
		}

		cameraIntent.setWindowId(TiIntentWrapper.createActivityName("CAMERA"));

		PackageManager pm = (PackageManager) activity.getPackageManager();
		List<ResolveInfo> activities = pm.queryIntentActivities(cameraIntent.getIntent(), PackageManager.MATCH_DEFAULT_ONLY);

		// See if it's the HTC camera app
		boolean isHTCCameraApp = false;

		for (ResolveInfo rs : activities) {
			try {
				if (rs.activityInfo.applicationInfo.sourceDir.contains("HTC")) {
					isHTCCameraApp = true;
					break;
				}
			} catch (NullPointerException e) {
				//Ignore
			}
		}

		if (!isHTCCameraApp) {
			cameraIntent.getIntent().putExtra(MediaStore.EXTRA_OUTPUT, Uri.parse(imageUrl));
		}

		OmadiCameraResultHandler resultHandler = new OmadiCameraResultHandler();
		resultHandler.imageFile = imageFile;
		resultHandler.imageUrl = imageUrl;
		resultHandler.successCallback = successCallback;
		resultHandler.cancelCallback = cancelCallback;
		resultHandler.errorCallback = errorCallback;
		resultHandler.activitySupport = activitySupport;
		resultHandler.cameraIntent = cameraIntent.getIntent();
		activity.runOnUiThread(resultHandler);
	}
	
	protected class OmadiCameraResultHandler implements TiActivityResultHandler, Runnable
	{
		protected File imageFile;
		protected String imageUrl;
		protected boolean saveToPhotoGallery;
		protected int code;
		protected KrollFunction successCallback, cancelCallback, errorCallback;
		protected TiActivitySupport activitySupport;
		protected Intent cameraIntent;

		@Override
		public void run()
		{
			code = activitySupport.getUniqueResultCode();
			activitySupport.launchActivityForResult(cameraIntent, code, this);
		}

		@Override
		public void onResult(Activity activity, int requestCode, int resultCode, Intent data)
		{
			if (resultCode == Activity.RESULT_CANCELED) {
				if (imageFile != null) {
					imageFile.delete();
				}
				if (cancelCallback != null) {
					cancelCallback.callAsync(getKrollObject(), new Object[] {});
				}

			} else {
				if (data == null) {
					ContentValues values = new ContentValues(7);
					values.put(Images.Media.TITLE, imageFile.getName());
					values.put(Images.Media.DISPLAY_NAME, imageFile.getName());
					values.put(Images.Media.DATE_TAKEN, new Date().getTime());
					values.put(Images.Media.MIME_TYPE, "image/jpeg");
					if (saveToPhotoGallery) {
						values.put(Images.ImageColumns.BUCKET_ID, PHOTO_DCIM_CAMERA.toLowerCase().hashCode());
						values.put(Images.ImageColumns.BUCKET_DISPLAY_NAME, "Camera");

					} else {
						values.put(Images.ImageColumns.BUCKET_ID, imageFile.getPath().toLowerCase().hashCode());
						values.put(Images.ImageColumns.BUCKET_DISPLAY_NAME, imageFile.getName());
					}
					values.put("_data", imageFile.getAbsolutePath());

					Uri imageUri = activity.getContentResolver().insert(Images.Media.EXTERNAL_CONTENT_URI, values);

					// puts newly captured photo into the gallery
					MediaScannerClient mediaScanner = new MediaScannerClient(activity, new String[] {imageUrl}, null, null);
					mediaScanner.scan();

					try {
						if (successCallback != null) {
							invokeCallback((TiBaseActivity) activity, successCallback, getKrollObject(), createDictForImage(imageUri.toString(), "image/jpeg"));
						}

					} catch (OutOfMemoryError e) {
						String msg = "Not enough memory to get image: " + e.getMessage();
						Log.e(LCAT, msg);
						if (errorCallback != null) {
							invokeCallback((TiBaseActivity) activity, errorCallback, getKrollObject(), createErrorResponse(UNKNOWN_ERROR, msg));
						}
					}

				} 
				else {
					// Get the content information about the saved image
					String[] projection = {
						Images.Media.TITLE,
						Images.Media.DISPLAY_NAME,
						Images.Media.MIME_TYPE,
						Images.ImageColumns.BUCKET_ID,
						Images.ImageColumns.BUCKET_DISPLAY_NAME,
						"_data",
						Images.ImageColumns.DATE_TAKEN
					};

					String title = null;
					String displayName = null;
					String mimeType = null;
					String bucketId = null;
					String bucketDisplayName = null;
					String dataPath = null;
					String dateTaken = null;

					Cursor c;
					if (data.getData() != null) {
						c = activity.getContentResolver().query(data.getData(), projection, null, null, null);
					}
					else {
						c = activity.getContentResolver().query(Images.Media.EXTERNAL_CONTENT_URI, projection, null, null, Images.ImageColumns.DATE_TAKEN);
					}
					if (c != null) {
						try {
							boolean isCursorValid = false;
							if (data.getData() != null) {
								isCursorValid = c.moveToNext();
							} else {
								isCursorValid = c.moveToLast();
							}
							if (isCursorValid) {
								title = c.getString(0);
								displayName = c.getString(1);
								mimeType = c.getString(2);
								bucketId = c.getString(3);
								bucketDisplayName = c.getString(4);
								dataPath = c.getString(5);
								dateTaken = c.getString(6);

								if (DBG) {
									Log.d(LCAT,"Image { title: " + title + " displayName: " + displayName + " mimeType: " + mimeType +
										" bucketId: " + bucketId + " bucketDisplayName: " + bucketDisplayName +
										" path: " + dataPath + " }");
								}
							}
						} finally {
							if (c != null) {
								c.close();
								c = null;
							}
						}
					}

					String localImageUrl = dataPath;

					if (!saveToPhotoGallery) {

						// We need to move the image from dataPath to imageUrl
						try {
							URL url = new URL(imageUrl);

							File src = new File(dataPath);
							File dst = new File(url.getPath());

							BufferedInputStream bis = null;
							BufferedOutputStream bos = null;

							try {
								bis = new BufferedInputStream(new FileInputStream(src), 8096);
								bos = new BufferedOutputStream(new FileOutputStream(dst), 8096);

								byte[] buf = new byte[8096];
								int len = 0;

								while((len = bis.read(buf)) != -1) {
									bos.write(buf, 0, len);
								}

							} finally {
								if (bis != null) {
									bis.close();
								}

								if (bos != null) {
									bos.close();
								}
							}

							// Update Content
							ContentValues values = new ContentValues();
							values.put(Images.ImageColumns.BUCKET_ID, imageFile.getPath().toLowerCase().hashCode());
							values.put(Images.ImageColumns.BUCKET_DISPLAY_NAME, imageFile.getName());
							values.put("_data", imageFile.getAbsolutePath());

							if (data.getData() != null) {
								activity.getContentResolver().update(data.getData(), values, null, null);
							} else {
								activity.getContentResolver().update(Images.Media.EXTERNAL_CONTENT_URI, values, "datetaken = ?", new String[] {dateTaken});
							}

							src.delete();
							localImageUrl = imageUrl; // make sure it's a good URL before setting it to pass back.

						} catch (MalformedURLException e) {
							Log.e(LCAT, "Invalid URL not moving image: " + e.getMessage());

						} catch (IOException e) {
							Log.e(LCAT, "Unable to move file: " + e.getMessage(), e);
						}
					}

					try {
						if (successCallback != null) {
							invokeCallback((TiBaseActivity) activity, successCallback, getKrollObject(), createDictForImage(localImageUrl, "image/jpeg"));
						}

					} catch (OutOfMemoryError e) {
						String msg = "Not enough memory to get image: " + e.getMessage();
						Log.e(LCAT, msg);
						if (errorCallback != null) {
							invokeCallback((TiBaseActivity) activity, errorCallback, getKrollObject(), createErrorResponse(UNKNOWN_ERROR, msg));
						}
					}
				}
			}
		}

		@Override
		public void onError(Activity activity, int requestCode, Exception e) {
			if (imageFile != null) {
				imageFile.delete();
			}
			String msg = "Camera problem: " + e.getMessage();
			Log.e(LCAT, msg, e);
			if (errorCallback != null) {
				errorCallback.callAsync(getKrollObject(), createErrorResponse(UNKNOWN_ERROR, msg));
			}
		}
	}
	
	private void invokeCallback(TiBaseActivity callbackActivity, KrollFunction callback, KrollObject krollObject, KrollDict callbackArgs)
	{
		if (KrollRuntime.getInstance().isRuntimeThread()) {
			doInvokeCallback(callbackActivity, callback, krollObject, callbackArgs);

		} else {
			CallbackWrapper callbackWrapper = new CallbackWrapper(callbackActivity, callback, krollObject, callbackArgs);
			Message message = getRuntimeHandler().obtainMessage(MSG_INVOKE_CALLBACK, callbackWrapper);
			message.sendToTarget();
		}
	}
	
	private void doInvokeCallback(TiBaseActivity callbackActivity, KrollFunction callback, KrollObject krollObject, KrollDict callbackArgs)
	{
		if (callbackActivity.isResumed) {
			callback.callAsync(krollObject, callbackArgs);

		} else {
			CallbackWrapper callbackWrapper = new CallbackWrapper(callbackActivity, callback, krollObject, callbackArgs);
			Message message = getRuntimeHandler().obtainMessage(MSG_INVOKE_CALLBACK, callbackWrapper);
			message.sendToTarget();
		}
	}
	
	KrollDict createDictForImage(String path, String mimeType) {
		KrollDict d = new KrollDict();

		int width = -1;
		int height = -1;

		try {
			String fpath = path;
			if (!fpath.startsWith("file://") && !fpath.startsWith("content://")) {
				fpath = "file://" + path;
			}
			BitmapFactory.Options opts = new BitmapFactory.Options();
			opts.inJustDecodeBounds = true;

			// We only need the ContentResolver so it doesn't matter if the root or current activity is used for
			// accessing it
			BitmapFactory.decodeStream(
				TiApplication.getAppRootOrCurrentActivity().getContentResolver().openInputStream(Uri.parse(fpath)), null,
				opts);

			width = opts.outWidth;
			height = opts.outHeight;
		} catch (FileNotFoundException e) {
			Log.w(LCAT, "bitmap not found: " + path);
		}

		d.put("x", 0);
		d.put("y", 0);
		d.put("width", width);
		d.put("height", height);

		KrollDict cropRect = new KrollDict();
		cropRect.put("x", 0);
		cropRect.put("y", 0);
		cropRect.put("width", width);
		cropRect.put("height", height);
		d.put("cropRect", cropRect);

		String[] parts = { path };
		d.put("mediaType", MEDIA_TYPE_PHOTO);
		d.put("media", TiBlob.blobFromFile(TiFileFactory.createTitaniumFile(parts, false), mimeType));

		return d;
	}

	KrollDict createDictForImage(int width, int height, byte[] data) {
		KrollDict d = new KrollDict();

		d.put("x", 0);
		d.put("y", 0);
		d.put("width", width);
		d.put("height", height);

		KrollDict cropRect = new KrollDict();
		cropRect.put("x", 0);
		cropRect.put("y", 0);
		cropRect.put("width", width);
		cropRect.put("height", height);
		d.put("cropRect", cropRect);
		d.put("mediaType", MEDIA_TYPE_PHOTO);
		d.put("media", TiBlob.blobFromData(data, "image/png"));

		return d;
	}
	
	/**
	 * Object that is used to wrap required fields for async processing when invoking 
	 * success, error , etc callbacks for camera
	 */
	private class CallbackWrapper
	{
		public TiBaseActivity callbackActivity;
		public KrollFunction callback;
		public KrollObject krollObject;
		public KrollDict callbackArgs;

		CallbackWrapper(TiBaseActivity callbackActivity, KrollFunction callback, KrollObject krollObject, KrollDict callbackArgs)
		{
			this.callbackActivity = callbackActivity;
			this.callback = callback;
			this.krollObject = krollObject;
			this.callbackArgs = callbackArgs;
		}
	}

}

